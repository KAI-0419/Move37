# 📂 STEP 5: 앱 구조 및 와이어프레임 (App Architecture)

## 1\. Architectural Pattern: "The Monolith" (Single Scene)

모바일 환경에서 무거운 SLM 모델(1GB+)을 씬 전환 때마다 다시 로드하는 것은 불가능합니다. 따라서 **앱 실행 시 한 번만 로드**하고, 이후에는 절대 메모리에서 내리지 않습니다.

  * **Scene Strategy:** `MainScene` 하나만 존재.
  * **State Management:** `AppManager`가 현재 상태(Enum: `Boot` -\> `Lobby` -\> `Game` -\> `Analysis`)를 관리하며, 상태에 따라 적절한 UI 패널(Canvas Group)을 켜고 끕니다.
  * **UI Transition:** 패널 전환 시 `Fade In/Out` 대신 **`Glitch / Chromatic Aberration` (화면 찢어짐/노이즈)** 효과를 사용하여 "시스템 모드 변경" 느낌을 줍니다.

-----

## 2\. Unity GameObject Hierarchy (Hierarchy 트리 구조)

이 구조를 그대로 Unity 에디터에 생성해야 합니다.

```text
__MAIN_SCENE__
│
├── [Managers] (DontDestroyOnLoad X - Single Scene이라 불필요)
│   ├── AppManager (State Machine: Boot, Lobby, Game...)
│   ├── InputManager (New Input System)
│   ├── SoundManager (SFX, BGM)
│   └── SLM_Core (Unity Sentis / Model Inference Logic)
│
├── [Camera_Rig]
│   ├── Main Camera (Perspective)
│   └── UI Camera (Overlay)
│
├── [Lighting_Environment]
│   └── Global Volume (Post-processing: Glitch, Bloom, Vignette)
│
└── [UI_CANVAS] (Canvas Scaler: Scale With Screen Size)
    │
    ├── 1_Panel_Boot (Start Screen)
    │   ├── Background_Black
    │   └── Text_Console_Log (TMP)
    │
    ├── 2_Panel_Lobby (Dashboard)
    │   ├── Header_UserInfo
    │   ├── Chart_Humanity_Radar (Polygon Graphic)
    │   └── Btn_Start_Challenge (Large)
    │
    ├── 3_Panel_Game_Tactics (The Arena)
    │   ├── Top_Area_AI_Status
    │   │   ├── Vis_AI_Avatar (Abstract Shape)
    │   │   └── Text_Thinking_Process ("Analyzing...")
    │   ├── Center_Area_Board
    │   │   └── Grid_Layout_5x5 (RawImage holders)
    │   └── Bottom_Area_Player
    │   │   └── Text_System_Message
    │
    ├── 4_Panel_Analysis (Post-Game)
    │   ├── Graph_Win_Rate_Timeline
    │   ├── Text_Insight_Reasoning
    │   └── Btn_Return_Lobby
    │
    └── 99_Overlay_FX (최상단)
        └── Image_CRT_Scanline (Raycast Target Off)
```

-----

## 3\. UI Wireframe & Interaction Detail (화면별 상세)

'Less is More' 철학에 따라 불필요한 장식을 배제하고 \*\*정보(Data)\*\*와 **타이포그래피**에 집중합니다.

### A. Panel\_Boot (The Awakening)

  * **Visual:** 검은 화면. 구형 모니터의 초록색 또는 호박색(Amber) 텍스트.
  * **Elements:**
      * `Text_Log`: 좌측 상단에서 빠르게 흐르는 시스템 로그.
          * `> Loading Logic Modules... 42%`
          * `> Checking Neural Pathways... OK`
      * `Input_Biometric`: 화면 중앙에 지문 모양 아이콘이 깜빡임.
  * **Interaction:** 터치 시 `Glitch` 효과와 함께 0.2초 만에 `Panel_Lobby`로 전환.

### B. Panel\_Lobby (The Status)

  * **Visual:** 깔끔한 모던 UI + 약간의 사이버펑크 터치.
  * **Elements:**
      * **Center:** **[Radar Chart]**. 나의 5가지 능력치(논리, 직관, 대담성, 속도, 방어)가 오각형 그래프로 그려짐. AI와 대결할 때마다 이 그래프 모양이 바뀜.
      * **Bottom:** 화면 하단 1/3을 차지하는 거대한 **[START]** 버튼. 버튼 안에는 "SYNC WITH AI"라는 텍스트가 적혀 있음.
  * **Interaction:** START 버튼을 누르면 카메라가 오각형 그래프의 중심(Black Hole)으로 빨려 들어가는 줌인 연출 후 `Panel_Game`으로 전환.

### C. Panel\_Game\_Tactics (The Battle)

  * **Layout:** 세로 모드(Portrait) 기준.
      * **Top (30%): AI Zone.**
          * `AI_Avatar`: 인간 형상이 아님. 계속해서 형태가 변하는 기하학적 도형(Fractal). AI가 고민할 때 회전 속도가 빨라짐.
          * `Text_Thinking`: "`<think>` Calculating sacrifice path... `</think>`" 처럼 SLM의 사고 과정이 흐릿하게 흘러감.
      * **Center (40%): The Board.**
          * 5x5 그리드. 체스말은 픽셀 아트나 단순한 심볼(아이콘)로 표현. 배경은 어둡고 격자무늬만 은은하게 빛남.
      * **Bottom (30%): Player Zone.**
          * 내 유닛 상태 창. 그리고 AI가 보내는 메시지("당신의 실수는 여기서부터입니다.")가 뜨는 `Log_Box`.

### D. Panel\_Analysis (The Lesson)

  * **Visual:** 설계도(Blueprint) 느낌의 파란색/검은색 배경.
  * **Elements:**
      * `Timeline_Slider`: 게임 전체 턴을 0\~End까지 슬라이드 가능.
      * `Marker_Move37`: 타임라인 중간에 **붉은색 느낌표(\!)** 아이콘. AI가 승기를 잡은 결정적 순간(Move 37).
      * `Text_Insight`: 해당 마커를 누르면 SLM이 생성한 훈수(?)가 타이핑됨.
          * *"여기서 폰을 살린 것이 패착입니다. 폰을 버리고 중앙을 점령했어야 합니다."*

-----

## 4\. Technical Constraints for UI

코드를 짤 때 준수해야 할 기술적 제약 사항입니다.

1.  **Canvas Scaler:**
      * `UI Scale Mode`: Scale With Screen Size.
      * `Reference Resolution`: 1080 x 1920 (Portrait).
      * `Match`: Width(0.5) or Height(0.5) - 기기 비율에 따라 유연하게.
2.  **Asset Usage:**
      * 이미지 스프라이트 사용을 최소화하고, Unity 기본 `Image` 컴포넌트와 `TextMeshPro`만으로 디자인할 것 (용량 절감).
      * 복잡한 도형은 `Unity Vector Graphics` 패키지를 사용하거나 셰이더(Shader)로 처리.
3.  **Performance:**
      * 모든 텍스트는 `TextMeshProUGUI` 사용.
      * 리스트(로그 창) 구현 시 `Object Pooling` 필수 적용 (메모리 누수 방지).

-----

## 5\. Data Flow Architecture (데이터 흐름도)

스크립트 간 통신을 구현할 때의 참조 모델입니다.

```mermaid
graph TD
    UserInput[User Input (Touch)] -->|Action Event| GameLogic
    
    subgraph Core Engine
    GameLogic[Game Logic (MCTS)] -->|Move Data| BoardState
    BoardState -->|Check Win/Loss| GameLogic
    end
    
    subgraph AI Brain
    GameLogic -->|Request Move| AI_Agent
    AI_Agent -->|Thinking...| SLM_Model[On-Device SLM]
    SLM_Model -->|Reasoning Text| UI_Manager
    AI_Agent -->|Best Move| GameLogic
    end
    
    subgraph UI Presentation
    BoardState -->|Update Visuals| UI_Manager
    UI_Manager -->|Render| Screen
    end
```